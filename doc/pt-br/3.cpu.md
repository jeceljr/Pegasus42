- [1. Chaves, Portas Lógicas, Circuitos Combinacionais](1.comb.md)
- [2. Circuitos Sequenciais](2.seq.md)

---

# 3. Processadores

Todos os problemas computacionais podem ser resolvidos com uma FSM. Teoricamente. Na prática até problemas
relativamente reduzidos podem precisar de um número de estados absurdo e a máquina correspondente seria
impossivelmente cara para se construir (se não absolutamente impossível, se precisa de mais componentes
do que existem átomos no universo, por exemplo).

Imagine uma FSM para receber seis characteres de 7 bits cada cuja função é imprimir estes caracteres na
ordem invertida. Ela vai ter 8_865_353_597_185 (8 trilhões) de estados. O problema é que a única memória
do sistema é o registrador do estado atual e usar isso para guardar que caracteres já forma vistos não é
eficiente. 6x7 = 42 bits para guardar os caracteres enquanto 8 trihões de estados precisam de 44 bits
para representá-los.

Se usarmos uma FSM ligada a uma pequena memória externa o resultado seria bem melhor. Uma memória de
8 palavras de 8 bits cada estaria sobrando e uma FSM com 12 estados seria suficiente para controlá-la
para resolver o problema.

Em seu trabalho de 1936 o Alan Turing imaginou also ainda mais simples que uma memória: ele ligou a
FSM dele (que representou como tabelas no texto) a uma fita infinita com casa individuais que podem
conter um símbolo escolhido entre um certo alfabeto. Existe uma cabeça de leitura e
gravação que está posicionada numa das casas da fita. A entrada da FSM é o símbolo da casa atual da
fita e as saídas são um símbolo a ser gravado (possivelmente o mesmo se não quisermos alterar a fita
neste momento) e opcionalmente um comando para mover a cabeça para a casa da esquerda o da direita.

Hoje isso é conhecido como "Máquina de Turing". Um simulador muito interessante disponível na web
é (https://turingmachine.io/) que já inclue vários exemplos.

![simulador de Máquinas de Turing](../fig/3.00.turingmachine.io.png)

Aqui temos uma multiplicação de dois números binários. A mesma coisa como uma FSM pura teria um
número enorme de estados enquanto aqui só foram necessários 21 estados. Mas isto foi criado apenas
para estudar um problema matemático do tipo "existe uma Máquina de Turing capaz de ..." e não
ser algo prático. Cada problema requer a construção de uma Máquina de Turing própria, mas no final
do texto aparece uma proposta interessante: uma Máquina Universal de Turing que receberia na mesma
fita os dados de entrada e uma representação, na forma de uma sequência de símbolos, de
uma Máquina de Turing que resolva o problema desejado. Hoje chamamos isso de "interpretador". Uma
vez construida esta máquina, trocando a fita muda o funcionamento. É o que chamamos de "software".

## Arquitetura de von Neumann e de Harvard

O primeiro computador (ou "cérebro eletrônico" conforme a imprensa da época) divulgado para o público
foi o Eniac em 1946 (projetos anteriores foram mantidos em segredo por muitos anos). Projetado
por John Mauchly e J. Presper Eckert  na Universidade da Pennsylvania, a principal limitação do
ENIAC era a necessidade de reconfigurar o hardware via paineis de fios para cada novo problema. Então
mesmo durante o seu desenvolvimento eles passaram a discutir o sucessor, a ser chamado de EDVAC.

Um dos participantes destes debates era o John von Neumann e ele escreveu um relatório detalhado
com estas idéias. Outro participante, o Herman Goldstine, acabou distribuindo o relatório para grupos
externos com apenas o von Neumann como autor, por isso este estilo de computação é conhecido como
"arquitetura von Neumann" apesar de ter sido criada por um grupo.

![arquitetura von Neumann](../fig/3.01.vonneumann.svg)

O John von Neumann gostava de analogias com a biologia e por isso chamava as partes do computador de "orgãos"
e onde os dados ficavam de "memória" (outros, especialmente a IBM, preferiam termos como "armazenagem"
mas acabaram perdendo esta batalha).

A únidade de control é uma FSM, que já vimos. A unidade lógica e aritmética é uma versão mais complicada
so somador/subtrator que também já vimos. A entrada e a saída é diferente para cada computador, então vamos
ignorá-los por enquanto.

A memória guarda dados e os programas (como a fita da Máquina Universal de Turing). Um bit desta memória é
como o registrador, que já vimos. O que não falamos é como escolher um bit entre muitos, mas o multiplexador
é bem parecido com o mecanísmo usado. Um aspecto interessante da arquitetura de von Neumann é que o
processador central (CPU) pode ser feito com uma tecnologia completamente diferente da usar pela memória.
Alguns exemplos:

| Computador | CPU | Memória |
|------------|-----|---------|
| EDSAC | válvulas | tanques de mercúrio |
| IAS | válvulas | tubos de Williams |
| LGP-30 | válvulas | tambor magnético |
| PDP-8 | transistores | núclos de ferrite |
| PC moderno | chip digitais | chip com capacitores verticais |

O IAS é "Institute for Advanced Studies" de Princeton onde John von Neumann e equipe construiram o computador
do seu relatório. Por isso também é mais raramente conhecido como "arquitetura de Princeton". Isso é em
contraste com "arquitetura de Harvard" cujo nome é baseado no computador que a IBM construiu para Howard Aiken da
Universidade de Harvard. A única diferença é que a memória de dados e a memória de programas são separadas. A
separação permite uma instrução e um dado serem lidos ao mesmo tempo, o que facilita o projeto. Mas impede
que um programa modifique a si mesmo.

Hoje todos os computadores menos os mais simples são hibridos: diretamente no processador temos duas pequenas
memórias conhecidas como cache de instrução de nível 1 e cache de dados de nível 1. Estas memórias apenas guardam
cópias das informações mais recentes usadas pelo computador. Quando a informação desejada não está nelas, um
cache unificado de nível 2 é acessado. E pode existir um nível 3 de cache e finalmente chegamos à memória
principal única como na figura do von Neumann. Isto combina as vantagens de hardware da arquitetura Harvard
com as vantagens de programação da arquitetura von Neumann.

Mencionamos que as entradas e saídas são específicas para cada computador. Nos primeiros computadores isso se
refletia no conjunto de instruções. Um computador podia ter uma instrução para ler uma tecla e outra instrução
para gravar numa fita. Por volta de 1970 começou a ficar popular a idéia de fazer os dispositivos aparecerem
como posições especiais de memórias. Ai o processador podia usar as instruções "normais" para tudo. Dos
processadores mais usados, apenas o x86 (Intel e AMD) ainda usam instruções especiais para entrada e saída
e os outros usam "periféricos mapeados na memória", o que nós também faremos.

## MCPU16h

No relatório do EDVAC foi apresentada a idéia de representar um programa como uma série de números, onde os
bits mais significativos representariam a "ordem" sendo dada ao computador (hoje chamamos isso de "código de
operação", ou "opcode" reduzido em inglês) e os menos significativos o endereço da posição de memória a ser
usada nesta instrução. Muitas operações precisam de dois operandos e produzem um resultado que precisa
ser armazenado em algum lugar. Isso exigiria 3 endereços, mas o EDVAC herdou das calculadoras mecânicas a
idéia de um registrador especial chamado "acumulador" que serve de um dos operando e o destino do resultado
na maioria das instruções.

Quantas instruções diferentes vamos ter? Isso define quantos bits iremos precisar para o "opcode". Na verdade
é possível fazer tudo com uma única instrução, mas isso não é uma boa idéia do ponto de vista didático. Um
exemplo é as instrução SUBLEQ que tem 3 endereços, e subtrai o valor no primeiro endereço do que está no
segundo endereço (guardando o resulto ali) e se o resultado foi negativo ou igual ele salta para o terceiro
endereço. Programas escritos para um computador assim são quase tão difíceis de se entender quanto os da
Máquinda de Turing.

Uma alternativa mais razoável é o [MCPU](https://github.com/cpldcpu/MCPU) com suas 4 instruções (dois bits
para o "opcode"). O Tim Böscke foi inspirado pelo MPROZ com suas 3 instruções, mas a troca
das operações de memória para memória por um acumulador estilo EDVAC simplificou bastante o projeto.

O MCPU16h tem duas diferenças: enquanto o MCPU original tem 8 bits de largura e só sobravam 6 bits para o endereço
(apenas 64 bytes, o suficiente para os exemplos mais simples) o MCPU16h, como o nome diz, é de 16 bits
e os 14 bits de endereço permitem 16 mil palavras de 16 bits cada uma (32KB). E o "h" no fim do nome é
de Harvard. Só que como o EDVAC, o MCPU16h depende de poder modificar um programa enquanto executa mas
isso não é possível com a arquitetura Harvard. Só que o *Digital* tem uma memória de duas portas e vamos
usar isso para parecer que são duas memórias separadas mas o que é escrito numa pode ser lido na outra.

A escolha da arquitetura Harvard é para permitir o uso de um circuito combinacional para a unidade de controle.
Na arquitetura von Neumann (como o MCPU original) a leitura da instrução tem que ocorrer num ciclo e a
leitura de um operando no outro. Por isso a unidade de controle precisa ser um circuito sequencial, que é
um pouco mais complexo.

![PC do MCPU](../fig/3.02.mcpu_pc.svg)

Com este circuito simples, a cada borda de subida do relógio o PC avança para a próxima palavra. Neste caso
ligamos o "enable" do registrador PC em 1 já que nunca deixamos de alterar o PC. Mas num projeto mais completo
vão existir situações em que isso ocorre (se tivermos que esperar pela memória de instruções, por exemplo).

Vamos usar a memória com duas portas. A porta 2 que é limitado à leitura vai servir como memória de instruções.
Os sinais de controle da porta 1 estão ligados a valores constantes que não atrapalhem a operação (não gravando
nada, por exemplo).

![memória de duas portas](../fig/3.03.mcpu_mem.svg)

Quando a simulação começa a memória está cheia de 0s. Mais para a frente usaremos o conteúdo de um arquivo para
preencher a memória, mas por enquanto estamos editando os valores das primeiras palavras da memória cada vez
que a simulação começa só para ver que algo está acontecendo. A figura mostra o que acontece depois de duas
subidas do relógio.

O dado vindo da memória (0x7777 indicando que é o hexadecimal equivalente ao binário 0111011101110111) é dividido
num endereço de 14 bits (0x3777) e em dois bits de "opcode" (0 e 1). Estamos decodificando as instruções usando
apenas fios.

Vamos implementar a primeira das quatro instruções: JCC ("Jump if Carry Clear" - pule se o vai um estiver 0).
Precisamos escolher um "opcode" para esta instrução e escolhemos 1 e 1.

![instrução JCC](../fig/3.04.mcpu_jcc.svg)

Um multiplexador escolhe entre pular para o endereço indicado pela instrução ou somar 1 ao PC atual. O primeiro
caso só acontece se o opcode é o do JCC e se o bit *C* é 0. A porta AND de 3 entradas determina esta
situação e controla o multiplexador.

Aqui estamos fazendo um único circuito, mas normalmente a porta AND faria parte da unidade de controle enquanto
o multiplexador, registrador de PC e o somador fariam parte do que chamamos de "fluxo de dados". E a memória seria
algo separado da CPU.
```
clock C PC
program(0x0000, 0xC006, 0xC001, 0xC008)
0 1 0
C 1 1
C 1 2
C 0 1
C 1 2
C 0 1
C 0 6
```
Para testar o circuito precisamos tornar o PC uma saída para que possa ser comparado durante o teste. Inicializamos
as 4 primeiras palavras da memória com um pequeno programa de teste. A instrução 0 vai ser ignorada por enquanto e
as instruções 1, 2 e 3 são todas JCC. A primeira vez que a instrução 1 é executada (linha 5 do teste) o *C* é 1 e
PC é incrementado para 2. Na linhas linhas 7 e 9 a instrução 1 é executada outra vez, com *C* igual a 1 e *C* igual
a 0 respectivamente. Apenas no último caso ele não continua para 2, mas sim salta para 6.

![instruções JCC e NOR](../fig/3.05.mcpu_jcc_nor.svg)

A próxima instrução que vamos implementar é a NOR, para a qual escolhemos o opcode 0 e 0. Para isso precisamos de
um novo registrador de 16 bits que chamaremos de Acc. Teremos uma saída com este nome para poder usar nos testes.
O circuito NOR com largura 16 recebe um dado de Acc e o outro da memória e seu resultado volta para Acc.

Primeiro testamos JCC para ver se continua funcionando. Depois criamos um novo teste para NOR. O circuito precisa
passar pelos dois.
```
clock Acc
program(0x0004, 0x0000, 0x0001, 0x0002, 0xFFFF)
0 0
C 0
C 0xFFFB
C 4
C 0xFFFA
```
Curiosamente as palavras 0, 1 e 2 servem inicialmente como instruções mas depois são usadas como dados também.

A instrução STA ("STore Accumulator") vai ter o opcode 1 e 0. A saída de Acc vai ser o dado de entrada da memória
(que até agora era sempre 0). E o sinal *str* da memória vai ser acionado para esta instrução, gravando o dado
no endereço indicado.

![instruções JCC, NOR e STA](../fig/3.06.mcpu_jcc_nor_sta.svg)

Depois de verificar que os testes de JCC e do NOR continuam funcionando, criamos um novo teste para STA.
```
clock Acc
program(0x0004,0x8004,0xC000,0x0000,0xFFFF)
0 0
C 0
C 0
C 0
C 0xFFFF
C 0xFFFF
C 0xFFFF
C 0
C 0
C 0
C 0xFFFF
```
Não é possível testar STA sem também usar as outras instruções. Os resultados de gravar um dado só é visível
quando se lê de volta o dado e para isso precisamos do NOR. O teste usa JCC também só para manter o código
curto - uma sequência NOR, STA, NOR, STA, NOR... já serviria de teste.

A última instrução, o ADD, seria quase igual ao NOR se não fosse pela complicação do vai um. Mas como tanto
o ADD quanto o NOR escrevem em Acc precisamos de um multiplexador para decidir entre eles.

![mcpu completo](../fig/3.07.mcpu.svg)

Agora Acc precisa ser habilitado tanto para ADD (opcode 01) quando para NOR (opcode 00), então podemos trocar
a porta AND com as duas entradas invertidas por um inverso. O novo somador tem as mesmas entradas que o NOR.

A entrada *C* é trocada por um registrador *C* de apenas um 1 bit de largura. Isso vai nos obrigar a alterar
o teste JCC. A definição de JCC é que *C* é zerado independentemente se o salto acontece ou não. Isso é usado
para que duas instruções JCC seguidas sejam um desvio incondicional (que em outros processadores seria uma
instrução separada). A saída vai um do somador é forçada a ser 0 no caso de uma instrução JCC (ou de um STA,
mas neste caso não importa).

*C* precisa ser habilitado para as instruções ADD (opcode 01) e JCC (opcode 11), então basta usar diretamente
o bit mais de baixo do opcode.

Com isto o MCPU está completo e poderá executar programas complexos.

### Software

Já escrevemos pequennos programas para o MPCU16h nos testes que criamos. Mas indicar diretamente cada instrução
como um número hexadecimal ou binário, o que chamamos de "linguagem de máquina", fica inviável para programas
com mais de umas 10 instruções. Felizmente um programa chamado "montador" ("assembler" em inglês) pode ler
um texto em que cada linha corresponde a uma instrução em linguagem de máquina e letras indicam a operação
("NOR", "ADD", "STA" e "JCC" no caso do MCPU16h) e gerar a linguagem de máquina correspondente. Podemos marcar
algumas linhas usando rótulos textuais e ai usar este mesmo texto no campo de endereço de outras instruções e ai
o assembler cuida de calcular o valor real dos endereços associados aos rótulos.

Montadores mais avançados, como o *GNU as*, permitem a definição de "macros" que são textos (possivelmente com
parâmetros) que depois são expandidos em todos os lugares onde são usados no programa. Neste projeto usamos
este recurso para fazer uma versão do *as* (para o processador x86, por exemplo) gerar código de máquina para
o MCPU16h. Estas macros ficam no arquivo *mcpu16.inc* que tem em seu início:
```
absStart:
        .macro NOR a
        .word (0x3FFF & ((\a-absStart)/2))
        .endm

        .macro ADD a
        .word (0x3FFF & ((\a-absStart)/2)) | 0x4000
        .endm

        .macro STA a
        .word (0x3FFF & ((\a-absStart)/2)) | 0x8000
        .endm

        .macro JCC a
        .word (0x3FFF & ((\a-absStart)/2)) | 0xC000
        .endm
```
Um programa que inclua este arquivo vai poder escreve algo como "JCC myLoop" e os 16 bits correspondentes serão
gerados. Uma complicação é que *as* encara que um rótulo como "myLoop" é um valor relativo e não conseguiria,
em princípio, calcular a expressão que gera a instrução. A idéia é que um programa pode ser feito de vários
módulos e o montador traduz cada um e uma etapa posterior junta os módulos no programa final. Ai os endereços
só serão conhecidos depois disso. Mas os programas que escreveremos para o MCPU16h são relativamente simples e
não teremos mais de um módulo. Por isso definimos "absStart" como sendo o início do programa para que a
expressão "myLoop-absStart" seja um valor conhecido pelo montador.

Além das 4 instruções que o hardware entende, podemos aproveitar as macros para definir novas instruções como
pequenas sequências destas instruções. Por exemplo: CLR (limpa o acumulador para zero), LDA (carrega um valor
no acumulador), LDP (carrega um ponteiro no acumulador), LDI (carrega indiretamente no acumulador), NOT
(inverte o acumulador), JMP (pula incondicionalmente), JCS (pula se o *C* for 1), SUB (subtrai o acumulador
do valor) e CALL (chamada de subrotina). O uso destas "pseudo-instruções" gera programas um tanto grandes. Os
programas do MCPU16h são umas 10 vezes maiores do que os para processadores mais razoáveis.

As pseudo-instruções IN e OUT leem e gravam do último endereço da memória e o circuito deve detectar isso
e ler ou gravar de um periférico no lugar da memória. Também foram definidas as macros STARTCOUNT e COUNT
para controlar um circuito para medir a velocidade para comparação de diferentes processadores. Neste
projeto não implementaremos este circuito e estas pseudo-instruções irão mexer com a penúltima palavra da
memória sem nenhum efeito.

O comando "make", entre outras coisas, gera os arquivos .hex que usaremos para inicializar a memória em nossas simulações
no diretório *hex* usando os códigos fontes .S encontrados no diretório *soft*. Os programas *as* e
*objcopy* são usados pelo *make*. Mais para frente usaremos *riscv32-unknown-linux-gnu-as* no lugar do *as*
para cuidar de programas para o RISC-V. Usaremos .s (minúsculo) nos nomes do código fonte neste caso
para o *make* poder decidir qual montador usar.

![MCPU16h com terminal e teclado](../fig/3.08.mcputerm.svg)

O novo circuito está na parte inferior à direita. Um AND de 14 entradas indica quando o último endereço da
memória (0x3FFF) é acessado e neste caso o novo multiplexador seleciona o dado vindo do teclado para as
instruções NOR e ADD (enquanto STA e JCC nem usam este dado) ao invés da memória, que é selecionado para
qualquer outro endereço. Duas portas AND separado o acesso ao último endereço entre os casos de escrita
(STA) e leitura (qualquer outra instrução). A escrita vai para o terminal e a leitura vem do teclado.

A memória pode ser configurada como "Memória de programa" e na "Configuração específicas do circuito"
podemos indicar o arquivo *hex/3.01.testTerminal.hex* como "Arquivo de programa". Isto foi gerado de
```
.include "mcpu16.inc"

loop:
        LDA cp
        ADD adInst
        STA 0f
        CLR
0:      .word 0  /* will be replaced */
        STA char
        ADD minusOne
        JCC halt    /* zero terminated string */
        LDA char
        OUT
        LDA cp
        ADD one
        STA cp
        JMP loop

halt:   JMP halt

text:   .string16 "Hello world!"
cp:     .word (text-absStart)/2
char:   .word 0
```
Podemos executar este programa passo a passo clicando repetidamente na entrada *clock*. Se o *Digital*
abrir uma janela e escrever o texto esperado podemos considerar que o processador está funcionando
completamente (a instrução NOR não aparece na listagem mas é usada por pseudo-instruções como LDA).

Para uma segunda execução deste programa podemos configurar a entrada *clock* para pulsar em tempo
real.

Trocando a inicialização da memória por *hex/3.02.sine.hex* veremos uma senoide desenhada na tela
textualmente. O algorítmo CORDIC evita usar multiplicações.

Um terceiro exemplo é o jogo interativo 2048. O terminal mostra uma matriz de 4 por 4 números que
podem ser deslocado para cima, equerda, baixo ou direita pressionando teclas na pequena janela
entitulada "Teclado". O arquivo para a memória é *hex/3.03.term20248.hex*.

## drv32h

Em 2010 um grupo de pesquisa da Universidade da Califórnia Berkeley estava desenvolvendo um
circuito que precisava incluir um processador. Depois de avaliarem as alternativas disponíveis
eles resolveram que a melhor opção seria um projeto próprio. Afinal, este mesmo grupo tinha
criado o processador RISC em 1982 e o RISC II em 1983. O SOAR ("Smalltalk On A RISC") de 1984
e o SPUR de 1988 tinham continuado nesta tradição. Então o novo processador seria o quinto
desta linhagem: o RISC-V.

Eles definiram um conjunto bem pequeno de instruções mas com espaço para ter extensões opcionais.
A base pode ser de 32 bits (RV32I ou RV32E), 64 bits (RV64I ou RV64E) ou ainda 128 bits (RV128I).
As variantes "I" e "E" são idênticas fora o fato da "I" ter 32 registradores e a "E" apenas 16.

Um exemplo de extensão é a "M" que adiciona instruções de multiplicação e divisão. As instruções
básicas já são suficientes para implementar estas funções, mas instruções próprias podem
acelerar bastante certas aplicações ao custo de um hardware mais caro. A maioria das extensões
são como esta onde uma coisa que já era possível fica mais rápida. Uma extensão que traz nova
funcionalidade é a "A" que introduz instruções atômicas. Sem estas instruções não dá para
vários processadores ligados numa única memória coordenarem suas atividades.

No drv32h (RISC-V no Digital com base RV32I e arquitetura Harvard) iremos implementar apenas
as instruções da base e nenhuma das extensões.

### Instruções

As instruções básicas do RISC-V são de 32 bits, mas os dois bits de baixo são sempre 1 e 1. As
outras 3 combinações são usadas pela extensão "C" que usa instruções de 16 bits para tornar
os programas mais compactos. Os 7 bits de baixo são o código de operação e sem a extensão
"C" temos 32 combinações possíveis:

|         | 00...11 | 01...11 | 10...11 | 11...11 |
|---------|---------|---------|---------|---------|
| ..00011 | LOAD    | STORE   | MADD    | BRANCH  |
| ..00111 | LOAD-FP | STORE-FP| MSUB    | JALR    |
| ..01011 | cust0   | cust1   | NMSUB   | reserved|
| ..01111 | MISC-MEM| AMO     | NMADD   | JAL     |
| ..10011 | OP-IMM  | OP      | OP-FP   | SYSTEM  |
| ..10111 | AUIPC   | LUI     | reserved| reserved|
| ..11011 | OP-IMM32| OP32    | cust2   | cust3   |
| ..11111 | 48 bits | 64 bits | 48 bits | >=80 bits|

Apenas iremos implementar as instruções individuais JALR, JAL, AUIPC e LUI e os grupos de
instruções LOAD, STORE, BRANCH, OP-IMM e OP. Estas são apenas 9 das 32 possibilidades do
código principal de operação. Os grupos de instruções usam campos auxiliares de código
de operação para escolher as instrução individual.

As instruções MADD, MSUB, NMSUB e NMADD e os grupos LOAD-FP, STORE-FP e OP-FP são para
as extensões de ponto flutuante: "F" (ponto flutuante de 32 bits), "D" (ponto flutuante de
64 bits) e "Q" (ponto flutuante de 128 bits). Não usaremos isso no nosso projeto.

Os 5 bits de baixo são todos 1 para instruções maiores que 32 bits, mas nenhuma foi definida.
Os grupos OP-IMM32 e OP32 são para permitir que um RV64I ou RV128I possam também fazer
operações de 32 bits, mas num RV32I como o drv32h estas instruções não são usadas.

As marcadas como "reserved" serão usadas por extensões oficiais enquanto as "custX" são
onde extensões não oficiais devem ser implementadas.

![PC do drv32h](../fig/3.09.drv_pc.svg)

Eliminando a maior parte do circuito do MCPU16h voltamos a ter praticamente só o PC. Para o
drv32h aumentamos o PC de 14 para 32 bits (e também o multiplexadore o somador) e trocamos
o valor a ser somado para 4. Antes de enviar o valor de PC para ser um endereço de memória
descartamos os dois bits de baixo que serão usados para escolher um byte dentro de uma
palavra de 32 bits. A largura da memória também é 32 bits mas só aumentamos o endereço
para 21 bits (o que dá 8MB no total). Assim, quando o PC endereçar o byte 0x18 a memória
vai ler a palavra 6. Como os 9 bits de cima do endereço não estão ligados, a memória vai
se repetir 512 vezes pelo espaço de 4GB.

Inicializamos a memória com *hex/3.04.sine.hex* que é a versão para RISC-V do mesmo programa
que o MCPU16h rodou como *hex//3.02.sine.hex*. Enquanto este último arquivo tem 6874 bytes,
a versão RISC-V tem apenas 373 bytes.

Separamos a instrução lida nos dois bits de baixo (que devem sempre ser 1 e 1), 5 bits de
código principal de operação correspondentes à tabela logo acima e os demais bits.

![instrução JAL](../fig/3.10.drv_jal.svg)

---

- [4. FPGAs e Shin JAMMA](4.fpga.md)
- [5. Vídeo e Áudio](5.av.md)
- [6. Pegasus 42](6.pegasus42.md)
- [A. História](A.hist.md)
