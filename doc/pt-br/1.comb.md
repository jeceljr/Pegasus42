# 1. Chaves, Portas Lógicas, Circuitos Combinacionais

O objetivo deste workshop é a construção de um retro computador (mais ou menos equivalente
ao que as pessoas comprariam para ter em casa no início dos anos 1990) chamado Pegasus 42
e usá-lo para programar uns jogos simples. A idéia é que o projeto possa ser completamente
entendido desde o nível mais baixo até o sistema em geral.

Para isso usaremos inicialmente um simulador, e depois passaremos as usar uma FPGA (
Field Programmable Gate Array - um chip que pode ser reconfigurado para implementar
qualquer circuito digital). Para cada nível de abstração existem vários simuladores
que podemos usar. De um alto nível para baixo nível temos:

| Nível | Exemplo de Simuladores |
|-------|--------------------|
| Arquitetura | QEMU, MAME |
| Micro-arquitetura | SPIM, SimpleScalar |
| Transferência de Registradores | Verilator, ModelSim |
| Portas Lógicas | Digital, TkGate |
| Chaves | IRSIM, MOSSIM |
| Circuitos Analógicos | Spice, Xyce |
| Componentes | TCAD, DEVSIM |
| Física | Elmer, Matlab |

A vantagem de se usar um simulador ao invés do produto de verdade é poder ver
detalhes que seriam muito difíceis, senão impossível, de medir no circuito
real. Os simuladores de baixo nível mostram muito mais detalhes que os de alto
nível, mas são proporcionalmente mais lentos quando executados num mesmo computador.
Por isso apesar de ser possível simulador um computador completo usando o Spice,
talvez level minutos para o circuito simulado executar uma única instrução. Podemos
ter que esperar semanas para saber se ele carrega o sistema operacional ou não.
Normalmente usamos os simuladores de baixo nível para pequenos trechos do projeto
e simuladores de mais alto nível para o sistema completo.

Quando dissemos que o objetivo era entender o Pegasus 42 ao nível mais baixo
exageramos um pouco. Vamos considerar o nível de chaves como sendo o mais baixo
neste workshop. Apesar do *Digital* não ser otimizado para este nível, ele é suficiente
para ilustrar as idéias que serão apresentas em seguida. Ele também não é otimizado
para os níveis mais altos, mas para os projetos reduzidos que serão estudados ele
é suficiente (mas é lento demais para mostrar a operação de circuitos que geram
vídeo de maneira usável).

![system](../fig/1.00.sys.svg)

Uma representação abstrata de um sistema é um retêngulo com um número de entradas
e algumas saídas. Normalmente mostraremos as entradas vindo da esquerda e as saídas
indo para a direita, mas podemos ignorar esta regra se estiver deixando o desenho
mais confuso.

## Digital ou Analógica

A primeira escolha que precisamos fazer é a natureza das entradas e saídas do nosso
sistema. Nas entradas e saídas analógicas algum valor do nosso circuito (tensão, corrente, etc) é
análogo a algum valor do mundo (temperatura, brilho, etc). Nas entradas e saídas digitais
uma série de valores do circuito representam um único valor do mundo. Esta série pode
usar entradas ou saídas separadas (representação paralela) ou uma mesma entrada ou saída
ao longo do tempo (representação serial).

| característica | Analógico | Digital |
|----------------|-----------|---------|
| número de circuitos | um | um por dígito |
| precisão | depende da qualidade do circuito  | sempre igual ao número de digitos |
| ruído    | acumula a cada operação    | não passa da entrada para saída |

Os circuitos analógicos dominaram a computação até a metade do século 20, e a telecomunicação
até o fim do século 20. O fator mais importante era o número de circuitos já que os componentes
eram muito caros e a ligação deles um processo manual. Com a evolução dos circuitos integrados
o custo passou a ser muito baixo e os outros fatores levaram à digitalização da tecnologia.
Nosso projeto é digital.

A humanidade tem usado vários sistemas digitais diferentes para representar números, sendo
o mais popular o sistema posicional decimal com digitos indu-arábicos. Quanto mais valores
cada dígito pode ter, mas sensível fica aos ruídos. Mas quanto menos valores cada digito poder
ter, mais dígitos são necessários para representar o mesmo número. A melhor proteção possível
contra o ruído é quando cada dígito pode ter apenas 2 valores, como no sistema posicional binário.

Apesar do sistema binário precisar de mais dígitos (e, portanto, mais circuitos) que as alternativas,
cada circuito é mais simples de modo que é a opção que usaremos.

## Portas Lógicas

Os circuitos combinacionais são aqueles cuja saída (ou saídas) depende apenas da combinação das
entradas. No caso binário, cada digíto só pode ser ou 0 ou 1. Existem várias áreas da matemática
que são equivalentes quando são usados apenas dois valores.

| Área |   |   |   |   |   |
|------|---|---|---|---|---|
| Álgebra Booleana | 1 | 0 | inversão | soma | produto |
| Lógica de Predicados | verdade | falso | não | ou | e |
| Teoria dos Conjuntos | conjunto universal | conjunto vazio | complemento | união | intersecção |
| Circuitos de Chaves | 5V | 0V | normalmente fechado | paralelo | série |

Notações de todas estas áreas podem ser usadas para representar os circuitos combinacionais. Uma
outra representação possível é simplesmente uma tabela com uma linha para cada combinação de
entradas e indicando a saída correspondente. Chamamos isso de "tabela verdade" mesmo quando os
valores mostrados são 0 e 1 ao invés de falso e verdadeiro.

Não seremos completamente consistentes, podendo descrever um circuito como tendo a forma de
"soma de produtos" (Álgebra Booleana) e outro circuito como contendo "não e" (Lógica de Predicados).
Este último é a razão dos circuitos básicos serem conhecidos como "portas lógicas".

Para ilustrar estas idéias usaremos o simulador [Digital](https://github.com/hneemann/Digital),
como mencionamos anteriormente. O *Digital* foi escrito em Java e por isso é necessário instalar
esta linguagem no seu computador antes de poder usá-lo. A vantagem disso é que roda em computadores
com diferentes sistemas operacionais e diferentes processadores. O site indicado é o do código
fonte, mas isso só necessário para quem quer modificar o simulador. Na página tem um botão "Download"
para baixar *Digital.zip* com a versão mais recente da ferramenta.

### Chaves

Como falamos de circuitos de chaves, vamos começar por ai ligando duas chaves em paralelo entre
uma lâmpada e uma fonte de alimentação. No menu "Arquivo" selecionamos "Novo". Usando o menu
"Componentes", "Chaves", "Chave" posicionamos duas chaves simples como desejamos. Já em "Componentes",
"Entradas e Saídas", "LED" temos uma aproximação razoável para a lâmpada que desejamos (o *Digital*
tem opções mais sofisticadas mas não as usaremos aqui). Finalmente em "Componentes", "Conexões",
"Fonte" temos uma alimentação para o circuito. Note que todos os circuitos precisam de alimentação
e de um sinal terra, mas normalmente não mostramos estes e o simulador funciona assim mesmo. Mas
se formos construir o circuito de verdade precisamos nos lembrar deles.

![chaves paralelas](../fig/1.01.orSwitch.svg)

Se imaginarmos duas salas com duas portas entre elas, uma ao lado da outra (em paralelo), se uma
*ou* outra estiver aberta poderemos ir de uma sala para a outra. Se simularmos este circuito
(menu "Simulação", "Iniciar a simulação" ou então o botão com triângulo simples apontando para
a direita) veremos que o LED fica apagado. Mas se acionarmos a chave de cima ou a chave de baixo
(ou as duas) ele acende.

![chaves em série](../fig/1.02.andSwitch.svg)

Se imaginarmos duas salas com duas portas entre elas, uma depois da outra via um pequeno corredor
(em série), não basta que uma porta esteja aberta. Só será possível passar de uma sala para outra
se a primeira *e* e segunda porta estiverem abertas. Neste segundo circuito ligamos as chaves em
série e na simulação vemos que o LED permanece apagando a não ser que a primeira *e* a segunda
chave tenham sido pressionadas.

Vimos duas das tres equivalências entre chaves e áreas da matemática. A tabela indica a última
equivalência (inversão, não, complemento) como sendo uma chave normalmente fechada. Este tipo
de chave abre o circuito quando pressionada. Mas aqui iremos mostrar uma alternativa de depende
do nível de dispositivos (o único caso que em baixaremos até este nível neste projeto.)

![inversão com chave](../fig/1.03.notSwitch.svg)

Só usamos uma chave aqui e no lugar da alimentação usamos "Componentes", "Conexões", "Resistor
Pull-Up". Também precisamos de "Componentes", "Conexões", "Terra". Com a chave aberta uma corrente
passa pelo resistor e pelo LED, que fica aceso. Ao ser pressionada a chave oferece um caminho
para 0V e a corrente vinda do resistor passa por ela ao invés do LED, que se apaga.

![e, ou, inversão com chaves](../fig/1.04.aoiSwitch.svg)

Aqui temos um exemplo mais complexo usando a mesma idéia. Geralmente a porta AOI ("and/or/invert" - e/ou/inverte)
não é considerada porta básica e não a veremos mais neste projeto, mas ela é útil o suficiente
para ser incluida em muitas bibliotecas de projeto de circuito integrado. Em álgebra Booleana temos:
```
Z = !(AxB + CxD)
```
enquanto na lógica de predicados seria:
```
Z = não((A e B) ou (C e D))
```
Uma quarta representação do AOI (sendo a primeira a figura ou esquemático, a segunda a álgebra Booleana
e a terceira a equação lógica) seria a tabela verdade:

| A | B | C | D | Z |
|---|---|---|---|---|
| aberta | aberta | aberta | aberta | acesa |
| aberta | aberta | aberta | fechada | acesa |
| aberta | aberta | fechada | aberta | acesa |
| aberta | aberta | fechada | fechada | apagada |
| aberta | fechada | aberta | aberta | acesa |
| aberta | fechada | aberta | fechada | acesa |
| aberta | fechada | fechada | aberta | acesa |
| aberta | fechada | fechada | fechada | apagada |
| fechada | aberta | aberta | aberta | acesa |
| fechada | aberta | aberta | fechada | acesa |
| fechada | aberta | fechada | aberta | acesa |
| fechada | aberta | fechada | fechada | apagada |
| fechada | fechada | aberta | aberta | apagada |
| fechada | fechada | aberta | fechada | apagada |
| fechada | fechada | fechada | aberta | apagada |
| fechada | fechada | fechada | fechada | apagada |

A tabela mostra um problema - as entradas tem uma natureza (são acionadas por um dedo humano) e a
saída tem uma natureza bem diferente (luz saíndo do LED). Se queremos que as saídas de um circuito
possam ser usadas como entradas de um outro circuito para construir sistemas maiores elas precisam
ser do mesmo tipo. Felizmente foram inventadas chaves que são acionadas por eletricidade:
relés (1835), válvulas termiônicas (1904) e transistores (1947). Apesar do *Digital* poder simular
relés de modo limitado (como as chaves), vamos trocar as chaves do circuito AOI por transistores
MOSFET (Metal/Oxide/Silicon Field Effect Transistor) tipo N (negativo) que é usado em circuitos
integrados.

![e, ou, inversão NMOS](../fig/1.05.aoiNMOS.svg)

Além de trocarmos as chaves por "Componentes","Chaves","FET tipo N" também usamos "Componentes",
"Entradas e Saídas", "Entrada" e também "Saída" do mesmo menu para indicar que estes sinais podem
vir de outro circuito e os resultados podem ir para outro circuito. Na simulação podemos trocar
os valores das entradas e observar os valores da saida.

No menu "Análises", o itém "Analises" cria uma tabela verdade para o circuito e podemos verificar
que é a mesma do circuito com chaves. Um problema deste tipo de circuito, que chamamos de NMOS,
é que sempre que a saída é 0 existe uma corrente passando pelo resistor e gerando calor (e drenando
a bateria se esta for de onde vem a alimentação). Um outro tipo de transistor, o "FET tipo P",
é o oposto do tipo N e conduz corrente quando a entrada é 0. Se trocarmos o resistor por um
circuito complementar ao dos transistores N usando transistores P (em série quando o outro é
paralelo) o funcionamento do circuito continuará o mesmo mas sem que corrente fique passando
sempre.

![e, ou, inversão CMOS](../fig/1.06.aoiCMOS.svg)

A complexidade adicional do CMOS limtou este tecnologia a nichos (como relógios digitais) nos
anos 1960 e 1970, mas praticamente substituiu todos os outros tipos de circuitos nos anos 1980
quando o crescente número de transistores por chip (Lei de Moore) tornou gastar o dobro de
transistores uma boa solução para reduzir a potência.

### Portas Lógicas de uma entrada

Até agora vimos apenas uma porta lógica de uma entrada: Não.

Com uma só entrada, apenas duas combinações de entradas são possíveis: ou 0 ou 1. Sua tabela
verdade vai ter duas linhas. A saída para cada linha pode ter dois valores de modo que existem
2^2 = 4 tabelas verdades possíveis.

| A | Z |
|---|---|
| 0 | 0 |
| 1 | 0 |

Na primeira porta a saída é sempre 0. Não é de se surpreender que não falamos dela. Em
termos de circuito é só ligar a saída no fio terra.

| A | Z |
|---|---|
| 0 | 1 |
| 1 | 0 |

Esta é a porta Não que já vimos.

| A | Z |
|---|---|
| 0 | 0 |
| 1 | 1 |

Aqui a saída é igual à entrada. Como o primeiro circuito dá para fazer isso com apenas um fio.

| A | Z |
|---|---|
| 0 | 1 |
| 1 | 1 |

A última porta tem como saída sempre um. Isso também pode ser feito como um fio ligado
na alimentação.

Então das 4 portas possíveis apenas o Não é interessante. Note que se encararmos o valor de Z
em cada tabela como os bits de um número binário com a primeira linha tendo o dígito menos
significativo, poderemos chamar estas portas de "porta 0" (Z = 0), "porta" 1 (Z = !A), "porta 2"
(Z = A) e "porta 3" (Z = 1).

### Portas Lógicas de duas entradas

Usando o mesmo raciocínio, uma porta de duas entradas tem 4 combinações possíveis de entradas e
por isso sua tabela verdade tem 4 linhas. Usando o mesmo esquema de enumeração usaremos um
número binário de 4 dígitos indicando que existem 2^4 = 16 portas possíveis.

| saídas | equação | nome |
|--------|---------|------|
| 0 0 0 0 | Z = 0 |     |
| 0 0 0 1 | Z = !(A+B) | NOR |
| 0 0 1 0 | Z = Ax!B  |     |
| 0 0 1 1 | Z = !B |      |
| 0 1 0 0 | Z = !AxB |    |
| 0 1 0 1 | Z = !A |    |
| 0 1 1 0 | Z = (!AxB)+(Ax!B) | XOR |
| 0 1 1 1 | Z = !(AxB) | NAND |
| 1 0 0 0 | Z = AxB | AND |
| 1 0 0 1 | Z = (AxB)+(!Ax!B) | XNOR |
| 1 0 1 0 | Z = A |  |
| 1 0 1 1 | Z = A+!B |   |
| 1 1 0 0 | Z = B |  |
| 1 1 0 1 | Z = !A+B |   |
| 1 1 1 0 | Z = A+B | OR |
| 1 1 1 1 | Z = 1 |    |

As portas 0000 e 1111 na verdade não tem nenhum entrada, enquanto 0011, 0101, 1010 e 1100 ignoram uma
das entradas. Então estas 6 são o que vimos acima.

6 portas tem nomes no menu "Componentes", "Lógica" e um desenho correspondente. Existe um desenho
para AND (1000), OR (1110) e XOR (exclusive OR - 0110) e para o inverso deles colocamos uma bolinha
na saída e um "N" no início do nome. O *Digital* também permite colocar uma bolinha nas entradas e
ai podemos usar um AND para as portas 0010 e 0100 e uma porta OR para 1011 e 1101.

#### Soma de Produtos

Se olharmos as linhas do XOR e XNOR veremos que são as equações mais complicadas. No caso do XOR
o primeiro produto (AND) é !AxB e corresponde diretamente ao 1 da esquerda, enquanto Ax!B é que
gera o 1 da direita.

| saídas | produto |
|--------|---------|
| 0 0 0 1 | !Ax!B  |
| 0 0 1 0 | Ax!B   |
| 0 1 0 0 | !AxB   |
| 1 0 0 0 | AxB    |

Então o XOR é a soma (OR) do segundo e do terceiro produtos desta tabela. Isso é verdade para qualquer
porta lógica e pode ser expandido para qualquer número de entradas. Então nunca irão descobrir
no futuro uma porta lógica nova que não sabemos implementar. A tabela verdade pode ser transformada
diretamente num circuito.

Isso não quer dizer que o circuito produzido assim será muito bom. Usando este método para a penúltima
porta lógica teríamos
```
Z = (Ax!B)+(!AxB)+(AxB)
```
Mas sabemos que uma símples porta OR faz a mesma coisa. Felizmente a álgebra booleana tem regras de
simplificação parecidas com as regras da álgebra normal e existe um método gráfico (chamado de Mapa
de Karnough, que é uma das coisas que o *Digital* pode gerar) para reduzir ao máximo a lógica
mantendo a mesma operação.

## Múltiplos Bits

Uma desvantagem dos circuitos digitais em relação aos analógicos é a repetição dos mesmo circuito
para cada dígito. Se usarmos 32 bits para representar valores, teremos 32 cópias de cada circuito.

![multipĺos bits](../fig/1.07.multibit.svg)

O *Digital* tem um recurso para reduzir esta complexidade. Para cada entrada e saída, além de um nome
podemos definir uma "largura" em número de bits. No circuito acima mudamos *A*, *B*, *X* e *Y* para terem 4
bits cada uma. Em "Componentes","Conexão","Distribuidor" temos um meio para ligar sinais com diferentes
números de bits. Nos dois da esquerda a entrada foi configurada como "4" e a saída como "1,1,1,1" enquanto
no da direita foi o contrário. Além disso cada componente normal pode ser configurado para uma certa
largura. A porta ou exclusivo de cima foi configurada para 4 bits enquanto as quatro de baixo são 1 bit
cada.

Os dois circuitos devem ser completamente equivalentes, mas o de cima é mais fácil de se entender por
ser bem menor. E isso para 4 bits - a ganho para, por exemplo, 32 bits é proporcionalmente maior. Na
edição do circuito o *Digital* não tem nenhuma indicação visual de que a porta de cima é diferente das
outras, que as entradas e saídas são múltiplos bits ou que os fios ligando estarão carregando múltiplos
bits. Durante a simulação, no entanto, os fios de 1 bit são mostrados em verde escuro (para 0) ou verde
claro (para 1) enquanto os com vários bits continuam azul escuro para com o valor indicado acima do fio.
E "clicando" numa entrada de 1 bit ela inverte seu valor enquanto numa de múltiplos bits aparece uma
caixa de diálogo para definir o novo valor.

Usando "Análises","Análises" veremos a tabela verdade e podemos comparar os bits de *X* e de *Y* para
confirmar que os circuitos são realmente equivalentes. Com 256 linhas, no entanto, esta confirmação é
bem cansativa. E se fizermos qualquer alteração no circuito teremos que repetir este estudo da tabela
verdade. Felizmente o *Digital* permite automatizar isso via "Componetes","Diversos","Caso de Teste".
Editamos o teste (que chamamos de "eqv") para:
```
A B X Y

loop(a,16)
  loop(b,16)
        (a)  (b)  (a^b)  (a^b)
  end loop
end loop
```
Usando "Simulação","Executar testes" todas as 256 combinações de *a* e *b* são geradas para *A* e *B*
e *X* e *Y* são comparadas com *a XOR b*. Todos os testes que passam são mostrados em verde e todos os
que falham com um "x" vermelho. É possível examinar os detalhes para saber ondo ocorreu a falha.

Outra maneira que o *Digital* elimina complexidade é o uso de projetos hierarquicos. Vários componentes
podem ser combinados num circuito que pode ser mostrado como um bloco único num circuito de mais alto
nível. Qualquer projeto prático deve usar isso extensamente e também incluir muitos testes para cada
sub-circuito. Mas como o objetivo deste workshop é mostrar a complexidade de um computador, os projetos
que serão vistos terão o mínimo de níveis possível. Muitas vezes sub-circuitos são comparados às chamadas
de subrotinas nas linguagens de programação mas na verdade são mais equivalentes às macros.

## Decisões

Nas linguagens de programação temos construções como "if A then B else C" para usar uma entrada para escolher
entre duas outras entradas.

![multipĺexador de 2 entradas](../fig/1.08.mux2.svg)

Olhando a tabela verdade vemos que Z = B sempre que A é 1, mas Z = C se A for 0. Isso significa que
circuitos combinacionais podem tomar decisões. Na verdade podem escolher entre mais de duas alternativas,
como o "switch/case" nas linguagens de programação.

![multipĺexador de 8 entradas](../fig/1.09.mux8.svg)

Isso é mais complicado de testar pois com 8+3 = 11 entradas são 2048 combinações possíveis. O teste
exaustivo (t8x256) ainda é possível:
```
S_2 S_1 S_0   A_7 A_6 A_5 A_4 A_3 A_2 A_1 A_0  Z

loop(s,8)
  loop(a,256)
        bits(3,s) bits(8,a) bits(1,a>>s)
  end loop
end loop
```
Aqui estamos confirmando que a saída corresponde ao bit selecionado por *S* (*Z* é calculado deslocando
a entrada à direita de modo que o bit menos significativo é a entrada desejada). Um teste mais cuidadoso
é verificar que quando todas as entradas são 0 a saída também é e em seguida tornar uma entrada por vez
1 e a saída deve continuar 0 a não ser quando a entrada desejada é a que vai para 1. Ao invés de 8x256
testes precisamos de apenas 8x9. Neste caso o teste completo é até melhor, mas na fabricação de um
produto onde parte do custo é o tempo gasto no equipamento de teste a solução mais reduzida seria mais
vantajosa.

Nosso projeto usará muitos multiplexadores e o circuito mostrado é meio grande (e teria que ser repetido
32 vezes para selecionar entre 8 valores de 32 bits cada). Ao nível de portas lógicas esta é a melhor
solução, mas se descermos ao nivel de chaves é possível economizar transistores.

![multipĺexador de 8 entradas](../fig/1.10.mux8tr.svg)

Este circuito passa pelos mesmos testes que o circuito anterior. Na prática este uso de transistores de
passagem NMOS causa uma redução no sinal de saída mas com dois inversores este problema é eliminado.
Usar pares NMOS e PMOS de passagem é outra solução, mas a fiação fica meio complexa. A idéia de mostrar
isso é para que possamos usar multiplexadores nos nossos projetos sem nos preocuparmos demais com o custo deles.

---

- [2. Circuitos Sequenciais](2.seq.md)
- [3. Processadores](3.cpu.md)
- [4. FPGAs e Shin JAMMA](4.fpga.md)
- [5. Vídeo e Áudio](5.av.md)
- [6. Pegasus 42](6.pegasus42.md)
- [A. História](A.hist.md)
